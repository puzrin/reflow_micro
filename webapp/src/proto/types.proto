syntax = "proto3";

enum Constants {
  option allow_alias = true;

  CONSTANT_UNSPECIFIED = 0;
  // Initial temperature for all profiles
  START_TEMPERATURE = 30;
  // Static sizes for repeated/maps
  MAX_REFLOW_PROFILES = 10;
  MAX_REFLOW_SEGMENTS = 10;
  MAX_HISTORY_CHUNK = 100;
  // History IDs for tasks (selected to not conflict with profile IDs)
  HISTORY_ID_SENSOR_BAKE_MODE = 4000;
  HISTORY_ID_ADRC_TEST_MODE = 4001;
  HISTORY_ID_STEP_RESPONSE = 4002;
}

message Segment {
  // Target temperature in Celsius
  int32 target = 1;
  // Duration in seconds
  int32 duration = 2;
}

message Profile {
  // Unique profile identifier
  int32 id = 1;
  // Profile name
  string name = 2;
  // Temperature segments sequence
  repeated Segment segments = 3;
}

message ProfilesData {
  // Available profiles
  repeated Profile items = 1;
  // Currently selected profile id
  int32 selectedId = 2;
}

message Point {
  float x = 1;
  float y = 2;
}

message HistoryChunk {
  int32 type = 1;
  int32 version = 2;
  repeated Point data = 3;
}


message HeadParams {
  //
  // Temperature sensor calibration data
  //
  float sensor_p0_at = 1;
  float sensor_p0_value = 2;
  float sensor_p1_at = 3;
  float sensor_p1_value = 4;

  //
  // ADRC calibration data
  //

  // System response time (when temperature reaches 63% of final value)
  float adrc_response = 5;
  // Scale. Max derivative / power
  float adrc_b0 = 6;
  // ω_observer = N / τ. Usually 3..10
  // 5 is good for the start. Increase until oscillates, then back 10-20%.
  float adrc_N = 7;
  // ω_controller = ω_observer / M. Usually 2..5
  // 3 is a good for the start. Probably, changes not required.
  float adrc_M = 8;
}

enum SensorType {
  RTD = 0; // Standalone PT100
  TCR = 1; // Indirect measurement via heater's TCR (copper: 0.39%/°C, tungsten: 0.45%/°C)
}

enum HeadStatus {
  HeadDisconnected = 0;
  HeadInitializing = 1;
  HeadConnected = 2;
  HeadError = 3;
}

enum PowerStatus {
  PwrOff = 0;
  PwrInitializing = 1;
  PwrTransition = 2; // PC contract change
  PwrOK = 3;
  PwrFailure = 4;
}

enum DeviceHealthStatus {
  DevNotReady = 0;
  DevOK = 1;
  DevFailure = 2;
}

enum DeviceActivityStatus {
  Idle = 0;
  Reflow = 1;
  SensorBake = 2;
  AdrcTest = 3;
  StepResponse = 4;
  Bonding = 5;
}

message DeviceInfo {
  // Main
  DeviceHealthStatus health = 1;
  DeviceActivityStatus activity = 2;
  PowerStatus power = 3;
  HeadStatus head = 4;
  int32 temperature_x10 = 5;
  // Debug info
  uint32 peak_mv = 6;
  uint32 peak_ma = 7;
  uint32 duty_x1000 = 8; // PWM duty cycle [0..1000]
  uint32 resistance_mohms = 9;
  // Max possible power in mW, for current heater resistance
  // at current PD profile
  uint32 max_mw = 10;
}
